# commented lines are all checks/tests for common terms--some of these things might become dictionary helper functions eventually
# Right now I am writing files to two places: the csv versions go in a subfolder of inst/extdata (because I need them in order to pass to BayesACT)
# There are also Rda versions that will be available via data
# I think I will need a method to write datasets generated by the user (or loaded by the user) to the proper location so I can find them to give to BayesACT
# First I am going to worry about the public datasets

source_folder <- "data-raw/dicts"
file_list <- list.files(source_folder)

# identities <- list()
# behaviors <- list()
# settings <- list()
# mods <- list()
# emotions <- list()
# keys <- list()
# encodings <- list()

for(file in file_list){
  # should deal with the mean-only datasets and the SD/COV datasets separately
  path <- paste0(source_folder, "/", file)
  component <- stringr::str_extract(file, "(?<=_)[[:alpha:]]*(?=.)")
  key <- stringr::str_extract(file, "^[[:alnum:]]*(?=_)")
  filetype <- stringr::str_extract(file, "\\.[[:alpha:]]*$")
  datatype <- dplyr::case_when(
    grepl("COV", file) ~ "COV",
    grepl("SD", file) ~ "SD",
    TRUE ~ "mean"
  )

  firstline <- readLines(con = file(path, "r"), n = 1)
  if(grepl(',', firstline)){
    # the file is comma-separated
    sep <- ","
  } else {
    # file is space separated
    sep <- " "
  }

  if(grepl('term', firstline)){
    head <- TRUE
  } else {
    head <- FALSE
  }

  data <- read.table(path, header = head, sep = sep, quote = "", fill=FALSE)
  nc <- ncol(data)
  namesplaceholder <- list()
  for(i in 1:nc){
    namesplaceholder <- append(namesplaceholder, paste0("V", i))
  }
  names(data) <- namesplaceholder

  # keys <- append(keys, key)
  # encodings <- append(encodings, guess_encoding(path))

  if(datatype == "mean"){
    male <- data %>%
      dplyr::select(-c(V5:V7))
    female <- data %>%
      dplyr::select(-c(V2:V4))
    average <- data %>%
      dplyr::rowwise() %>%
      dplyr::mutate(avE = mean(c(V2, V5)),
             avP = mean(c(V3, V6)),
             avA = mean(c(V4, V7))) %>%
      dplyr::select(-c(V2:V7))

    if(ncol(female) == 5){
      colnames(male) <- c("term", "E", "P", "A", "instcodes")
      colnames(female) <- c("term", "E", "P", "A", "instcodes")
      colnames(average) <- c("term", "instcodes", "E", "P", "A")
      average <- dplyr::select(average, term, E, P, A, instcodes)
    } else {
      colnames(male) <- c("term", "E", "P", "A")
      colnames(female) <- c("term", "E", "P", "A")
      colnames(average) <- c("term", "E", "P", "A")
    }

    # standardize terms
    male <- standardize_terms(male, key, component)
    female <- standardize_terms(female, key, component)
    average <- standardize_terms(average, key, component)

    # if(component == 'identities'){
    #   identities <- append(identities, average[,1])
    # } else if (component == 'behaviors'){
    #   behaviors <- append(behaviors, average[,1])
    # } else if (component == 'mods'){
    #   mods <- append(mods, average[,1])
    # } else if (component == 'settings'){
    #   settings <- append(settings, average[,1])
    # } else if (component == 'emotions'){
    #   emotions <- append(emotions, average[,1])
    # }

    # are the male and female sets identical? If so the reported values are averages already and need only print one file
    if(isTRUE(all.equal(male$E, female$E))){
      avonly <- TRUE
    } else {
      avonly <- FALSE
    }

    # print average file first
    filename <- paste0(key, "_", component, "_av")
    saveit(average, name = filename)

    # then print male and female files if necessary
    if(avonly == FALSE){
      for(g in c("f", "m")){
        filename <- paste0(key, "_", component, "_", g)

        if(g == 'f'){
          d <- female
        } else {
          d <- male
        }

        saveit(d, name = filename)
      }
    }

    # now deal with covariance datasets which will be different.
    # The one provided (georgia-duke 2015; probably same data as UGA 2015) does not split by gender
    # cov data has 9 additional columns
    # honestly can probably just leave as is maybe with the exception of standardizing term format
  } else if (datatype == "COV") {
    names(data) <- c('term', 'E', 'P', 'A', 'cov1', 'cov2', 'cov3', 'cov4', 'cov5', 'cov6', 'cov7', 'cov8', 'cov9')
    data_clean <- standardize_terms(data, key, component)
    filename <- paste0(key, "_", component, "_av_COV")
    saveit(data_clean, name = filename)

    # if(component == 'identities'){
    #   identities <- append(identities, data_clean[,1])
    # } else if (component == 'behaviors'){
    #   behaviors <- append(behaviors, data_clean[,1])
    # } else if (component == 'mods'){
    #   mods <- append(mods, data_clean[,1])
    # } else if (component == 'settings'){
    #   settings <- append(settings, data_clean[,1])
    # } else if (component == 'emotions'){
    #   emotions <- append(emotions, data_clean[,1])
    # }
  } else if (datatype == "SD") {
    # standard deviation has three additional columns; does not split by gender
    names(data) <- c('term', 'E', 'P', 'A', 'sd1', 'sd2', 'sd3')
    data_clean <- standardize_terms(data, key, component)
    filename <- paste0(key, "_", component, "_av_SD")
    saveit(data_clean, name = filename)

    # if(component == 'identities'){
    #   identities <- append(identities, data_clean[,1])
    # } else if (component == 'behaviors'){
    #   behaviors <- append(behaviors, data_clean[,1])
    # } else if (component == 'mods'){
    #   mods <- append(mods, data_clean[,1])
    # } else if (component == 'settings'){
    #   settings <- append(settings, data_clean[,1])
    # } else if (component == 'emotions'){
    #   emotions <- append(emotions, data_clean[,1])
    # }
  }
}

# identities_sum <- unlist(identities) %>%
#   as_tibble_col() %>%
#   rename(term = value) %>%
#   mutate(term = as.character(term))%>%
#   group_by(term) %>%
#   summarize(n = n())
#
# behaviors_sum <- unlist(behaviors) %>%
#   as_tibble_col() %>%
#   rename(term = value) %>%
#   mutate(term = as.character(term)) %>%
#   group_by(term) %>%
#   summarize(n = n())
#
# mods_sum <- unlist(mods) %>%
#   as_tibble_col() %>%
#   rename(term = value) %>%
#   mutate(term = as.character(term)) %>%
#   group_by(term) %>%
#   summarize(n = n())
#
# settings_sum <- unlist(settings) %>%
#   as_tibble_col() %>%
#   rename(term = value) %>%
#   mutate(term = as.character(term)) %>%
#   group_by(term) %>%
#   summarize(n = n())
#
# emotions_sum <- unlist(emotions) %>%
#   as_tibble_col() %>%
#   rename(term = value) %>%
#   mutate(term = as.character(term)) %>%
#   group_by(term) %>%
#   summarize(n = n())


